"""
# Helpers for node simulation.

This module is mainly intended to provide abstractions over network devices
and other mechanisms that are out of the scope of the routing aspect of this
simulation.

## Wireless interface abstraction

The wireless interface abstraction provides the following methods to the simulation:
 - `send_packet(packet)` method: Sends an IP packet to the other end of the point-to-point
   connection established.
 - `start_ap_mode()` method: Tries to start AP mode in the interface. This may fail if there's
   another interface configured as AP in the same channel. Note that for this simulation all 
   interfaces will be working in the same channel.
 - `connect_to_peer()` method: Tries to connect to a wireless peer that is in AP mode.
 - `reset_interface()` method: Resets the interface to its initial state, closing all active connections.

Most of the communication with the wireless interface is done through events. The following events
are generated by the simulated wireless interface:
 - Event `PacketReceived`: An IP packet has been received from the other end of the established
   connection.
 - Event `PeerConnected`: A connection has been established with a peer.
 - Event `PeerLost`: Connection to wireless peer has been lost.

### Assumptions made
 - Since this is a point-to-point connection, we'll not care about Ethernet frames, and instead
   assume that any IP packet sent through this interface will reach the only peer that's on the
   other end of the connection, regardless of the packet's destination address.
 - For all non-root nodes, the IP addresses of the hosts at each end of the wireless connection 
   will be `192.168.1.1` and `192.168.1.2`, it's unimportant which address is assigned to each 
   host.
 - For the root node, it's assumed that the IP assigned to the root node's end of the wireless 
   connection is the public IP address that will be used for NAT. Note that since the simulation
   will run inside a Docker container, this IP will be the private IP assigned to the container.
   This implies that we might be double or triple NAT-ing -- that's OK for this simulation.

### Implementation

The simulated wireless interface is implemented using Unix SEQPACKET sockets. We'll use Unix sockets
because they act as a reliable way for IPC and it's easy to share them between containers without 
the need of using routing tables (which may be changed or used for the simulation).

We'll use SEQPACKET instead of UDP or TCP because:
 - We want a datagram stream, since we're sending IP packets. This rules out TCP.
 - We want a connection-oriented socket because that's similar to how WiFi works: you connect to an AP
   and then you can send datagrams to any host in the network. This rules out UDP.

We'll simulate WiFi actions as follows:
  - Setting up the interface as AP mode means creating the socket file
  - Scanning for wireless networks means reading the directory where the socket file should be. This
    directory is fixed and defined by the simulation, since the directory will act as the "physical"
    location of the node / direction of the antenna.
  - Connecting to the AP means connecting to the socket file

Since Unix sockets are reliable, we are not going to send any packets between the processes to synchronize,
we'll assume that the point-to-point connection is established once the sockets are connected.


## SPI interface abstraction

The SPI interface is simpler than the wireless interface because the connections are assets and peers can
never be lost. For this case, there is only a single event that can be generated, PacketReceived, and there
is only one method provided, `send_packet`.

Communication between SPI interfaces is done through queues.
"""
